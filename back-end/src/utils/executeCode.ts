import { spawn } from "child_process";
import { ID, TimeoutTimeInSeconds } from "../config/constants";
import { createCodeFile, removeCodeFile } from "./codeFileManager";
import { ICommands, getCodeCompileAndExecuteCommands } from "./commands";
import { TLanguage } from "./validationSchema";

/**
 * This function executes code in a specified language with given input and returns the output, error,
 * and execution time.
 * @param {string} code - The code parameter is a string that represents the code to be executed.
 * @param {TLanguage} language - The programming language of the code being executed.
 * @param {string} input - The input parameter is a string that represents the input that will be
 * passed to the code being executed. It is used to simulate user input for programs that require user
 * input during runtime.
 * @returns The `executeCode` function returns a Promise that resolves to an object containing the
 * `error`, `output`, and `executionTime` properties. The `error` property contains any error messages
 * generated during the execution of the code, the `output` property contains the output generated by
 * the code, and the `executionTime` property contains the time taken to execute the code. If there was
 * an error
 */
export const executeCode = async (
  code: string,
  language: TLanguage,
  input: string
) => {
  const { codeId } = createCodeFile(code, language);
  const {
    compileCommand,
    compilationArgs,
    executeCommand,
    executionArgs,
  }: ICommands = getCodeCompileAndExecuteCommands(codeId, language);

  let start = Date.now();

  if (compileCommand) {
    try {
      await new Promise((resolve, reject) => {
        const compileCodeProcess = spawn(compileCommand, compilationArgs || []);
        compileCodeProcess.stderr.on("data", (data: Buffer) => {
          reject(data.toString());
        });
        compileCodeProcess.on("exit", (code: number) => {
          resolve(code);
        });
      });
    } catch (err) {
      console.log(err);
      removeCodeFile(codeId, language);
      return { error: err, output: "", executionTime: 0 };
    }
  }
  const result = await new Promise((resolve, reject) => {
    const executeChildProcess = spawn(executeCommand, executionArgs || [], {
      uid: ID,
      gid: ID,
    });

    const timerId = setTimeout(() => {
      executeChildProcess.kill();
      removeCodeFile(codeId, language);
      reject(
        "Process timed out! \nOne of the reason could be no input provided."
      );
    }, TimeoutTimeInSeconds * 1000);

    let output = "",
      error = "";

    if (input) {
      executeChildProcess.stdin.on("error", (err: Object) => {
        console.error(`Error writing to stdin: ${err}`);
      });
      executeChildProcess.stdin.writableHighWaterMark;
      const lineByLineInput = input.split("\n");
      for (const line of lineByLineInput) {
        executeChildProcess.stdin.write(line + "\n");
      }
      executeChildProcess.stdin.end();
    }

    executeChildProcess.stdout.on("data", (data: Buffer) => {
      output += data.toString();
    });

    executeChildProcess.stderr.on("data", (data: Buffer) => {
      error += data.toString();
    });

    executeChildProcess.on("error", (err: Object) => {
      console.log(err);
      clearTimeout(timerId);
    });

    executeChildProcess.on("exit", (code: number) => {
      const executionTime = Date.now() - start;
      console.log("execution time : ", executionTime);
      resolve({ error, output, executionTime });
      clearTimeout(timerId);
    });
  });
  removeCodeFile(codeId, language);

  return result;
};
